using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EndpointConfigurator;

[Generator(LanguageNames.CSharp)]
public class SourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var erbType = context.CompilationProvider
            .Select(static (c, _) => c.GetTypeByMetadataName("Microsoft.AspNetCore.Routing.IEndpointRouteBuilder"));

        var types = context.SyntaxProvider.CreateSyntaxProvider(IsCorrectAttribute, GetMethodFromAttribute)
            .Where(t => t != null)
            .Combine(erbType)
            .Collect();

#pragma warning disable CS8622
        context.RegisterSourceOutput(types, GenerateSource);
#pragma warning restore CS8622
    }

    private static bool IsCorrectAttribute(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = attribute.Name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };

        return IsCorrectAttributeName(name);
    }

    private static bool IsCorrectAttributeName(string? name) => name == "EndpointConfig" || name == "EndpointConfigAttribute";

    private static IMethodSymbol? GetMethodFromAttribute(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not MethodDeclarationSyntax methodNode)
            return null;

        if (context.SemanticModel.GetDeclaredSymbol(methodNode, cancellationToken) is not IMethodSymbol method)
            return null;

        if (!method.CanBeReferencedByName)
            return null;

        return method;
    }

    private static void ReportOnAttribute(SourceProductionContext context, ISymbol symbol, DiagnosticDescriptor diagnosticDescriptor)
    {
        var attribute = symbol.GetAttributes().First(a => IsCorrectAttributeName(a.AttributeClass?.Name));
        var location = attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation();
        context.ReportDiagnostic(Diagnostic.Create(diagnosticDescriptor, location));
    }

    private static void GenerateSource(SourceProductionContext context, ImmutableArray<(IMethodSymbol, INamedTypeSymbol)> items)
    {
        if (items.IsDefaultOrEmpty)
            return;

        var source = new CodeBuilder();
        source.AppendLine($"//------------------------------------------------------------------------------");
        source.AppendLine($"// <auto-generated>");
        source.AppendLine($"//     This code was generated by a source generator.");
        source.AppendLine($"//");
        source.AppendLine($"//     Changes to this file may cause incorrect behavior and will be lost if");
        source.AppendLine($"//     the code is regenerated.");
        source.AppendLine($"// </auto-generated>");
        source.AppendLine($"//------------------------------------------------------------------------------");
        source.AppendLine($"");

        source.AppendLine("[System.Runtime.CompilerServices.CompilerGenerated]");
        source.AppendLine("public static class EndpointExtensions_" + Guid.NewGuid().ToString("N"));
        source.StartBlock();
        source.AppendLine("public static void MapEndpoints(this IEndpointRouteBuilder app)");
        source.StartBlock();

        foreach (var (method, erbType) in items)
        {
            if (!method.IsStatic)
            {
                ReportOnAttribute(context, method, new DiagnosticDescriptor(
                    id: "EP0001",
                    title: "Config method must be static",
                    messageFormat: "Config method must be static",
                    category: nameof(EndpointConfigurator),
                    defaultSeverity: DiagnosticSeverity.Warning,
                    isEnabledByDefault: true
                ));
                continue;
            }

            if (method.Parameters.Length != 1)
            {
                ReportOnAttribute(context, method, new DiagnosticDescriptor(
                    id: "EP0002",
                    title: "Config method must have only 1 argument",
                    messageFormat: "Config method must have only 1 argument",
                    category: nameof(EndpointConfigurator),
                    defaultSeverity: DiagnosticSeverity.Warning,
                    isEnabledByDefault: true
                ));
                continue;
            }

            if (!method.Parameters[0].Type.Equals(erbType, SymbolEqualityComparer.Default))
            {
                ReportOnAttribute(context, method, new DiagnosticDescriptor(
                    id: "EP0003",
                    title: "Config method must take 1 argument of correct type",
                    messageFormat: "Config method must take 1 argument of type " + erbType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                    category: nameof(EndpointConfigurator),
                    defaultSeverity: DiagnosticSeverity.Warning,
                    isEnabledByDefault: true
                ));
                continue;
            }

            var type = method.ContainingType;

            if (type == null)
                continue;

            source.AppendLine($"{type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{method!.Name}(app);");
        }

        source.EndBlock();
        source.EndBlock();

        context.AddSource("EndpointExtensions.g.cs", source.ToSourceText(Encoding.UTF8));
    }
}
